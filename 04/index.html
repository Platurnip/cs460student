<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Flashy Fish!</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;

      
        background: url("underwater2.jpg");
        background-size: cover;
        background-position: center;
        cursor: crosshair;
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>

  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;
    uniform mat4 u_transform;
    uniform float u_pointsize;

    void main(void) {
      gl_Position = u_transform * vec4(a_position, 1.0);
      gl_PointSize = u_pointsize; 
    }
  </script>

  <script id="fragmentshader" type="glsl">
    precision mediump float;
    uniform vec4 u_color;

    void main(void) {
      gl_FragColor = u_color;
    }
  </script>

  <script>
    var c, gl, shaderprogram, all_fish = [];
    var targetPos = [0, 0];         
    var redFishControlled = false;  

    window.onload = function() {
      c = document.getElementById('c');
      c.width = innerWidth;
      c.height = innerHeight;
      gl = c.getContext('webgl');
      gl.viewport(0, 0, c.width, c.height);

      c.addEventListener("mousemove", (e) => {
        let x = (e.clientX / c.width) * 2 - 1;
        let y = -((e.clientY / c.height) * 2 - 1);
        targetPos = [x, y];
      });

      c.addEventListener("click", () => {
        redFishControlled = !redFishControlled;
      });

      var v_shader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(v_shader, document.getElementById('vertexshader').innerText);
      gl.compileShader(v_shader);
      console.log("Vertex Shader:", gl.getShaderInfoLog(v_shader));

      var f_shader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(f_shader, document.getElementById('fragmentshader').innerText);
      gl.compileShader(f_shader);
      console.log("Fragment Shader:", gl.getShaderInfoLog(f_shader));

      shaderprogram = gl.createProgram();
      gl.attachShader(shaderprogram, v_shader);
      gl.attachShader(shaderprogram, f_shader);
      gl.linkProgram(shaderprogram);
      gl.useProgram(shaderprogram);

      all_fish.push(createFish([0, 0, 0], [1, 0, 0, 0.7], 1, -1));

      for (let i = 0; i < 100; i++) {
        let col = [Math.random(), Math.random(), Math.random(), 0.5 + 0.5 * Math.random()];
        let off = [Math.random() * 2 - 1, (Math.random() * 2 - 1) * 0.8, 0];
        let sc = Math.random() * 0.3;
        let dir = 1;
        let rotationPhase = Math.random() * Math.PI * 2;
        let speedFactor = 0.8 + Math.random() * 0.4;
        let wiggleAmp = 0.1 + Math.random() * 0.2;
        let rotationSpeed = 2.0 + Math.random() * 2.0;
        all_fish.push(createFish(off, col, sc, dir, rotationPhase, speedFactor, wiggleAmp, rotationSpeed));
      }

      animate();
    };

    function createFish(offset, color, scale, direction, rotationPhase = 0, speedFactor = 1.0, wiggleAmp = 0.2, rotationSpeed = 2.0) {
      var verts = new Float32Array([
        0.5, 0.0, 0.0,
        0.2, 0.25, 0.0,
       -0.2, 0.15, 0.0,
       -0.4, 0.3, 0.0,
       -0.4, -0.3, 0.0,
       -0.2, -0.15, 0.0,
        0.2, -0.25, 0.0
      ]);
      var idx = new Uint8Array([0,1,6, 1,2,6, 2,5,6, 2,3,5, 3,4,5]);

      let vb = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vb);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

      let ib = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);

      let eye_y = (direction == -1) ? -0.2 : 0.2;
      let eye_vb = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, eye_vb);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.2, eye_y, 0.0]), gl.STATIC_DRAW);

      return {
        vb, ib, eye_vb,
        off: new Float32Array(offset),
        col: new Float32Array(color),
        sc: scale,
        dir: direction,
        phase: rotationPhase,
        baseY: offset[1],
        speedFactor,
        wiggleAmp,
        rotationSpeed
      };
    }

    function animate() {
      requestAnimationFrame(animate);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.disable(gl.DEPTH_TEST);

      let time = performance.now() * 0.001;

      for (let r = 0; r < all_fish.length; r++) {
        let f = all_fish[r];
        let { vb, ib, eye_vb, off, col, sc, dir, phase, baseY, speedFactor, wiggleAmp, rotationSpeed } = f;

        if (r === 0) {
          if (redFishControlled) {
            let lerp = 0.05;
            off[0] += (targetPos[0] - off[0]) * lerp;
            off[1] += (targetPos[1] - off[1]) * lerp;
          } else {
            let baseSpeed = 0.0025;
            off[0] += baseSpeed * dir;
            off[1] = baseY + Math.sin(time * 1.5 + phase) * 0.05;
            if (off[0] > 1.3) off[0] = -1.3;
            if (off[0] < -1.3) off[0] = 1.3;
          }
        } else {

          let baseSpeed = 0.0045;
          off[0] += baseSpeed * speedFactor * dir;
          off[1] = baseY + Math.sin(time * 2.0 * speedFactor + phase) * wiggleAmp;
          if (off[0] > 1.4) off[0] = -1.4;
          if (off[0] < -1.4) off[0] = 1.4;
        }

        let theta = 0.2 * Math.sin(time * rotationSpeed + phase);

        let transform = [
          dir * sc * Math.cos(theta), Math.sin(theta), 0, 0,
         -Math.sin(theta), dir * sc * Math.cos(theta), 0, 0,
          0, 0, dir * sc, 0,
          off[0], off[1], off[2], 1
        ];

        let a = 0.6 + 0.4 * Math.sin(time * 2.0);
        let current_color = new Float32Array([
          0.3 + 0.2 * Math.sin(time + 0.0),
          0.6 + 0.2 * Math.sin(time + 2.0),
          0.9 + 0.1 * Math.sin(time + 4.0),
          a
        ]);
        if (r === 0) current_color = new Float32Array([1, 0, 0, 0.7]);

        gl.bindBuffer(gl.ARRAY_BUFFER, vb);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
        let a_pos = gl.getAttribLocation(shaderprogram, 'a_position');
        gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_pos);

        let u_t = gl.getUniformLocation(shaderprogram, 'u_transform');
        gl.uniformMatrix4fv(u_t, false, new Float32Array(transform));

        let u_col = gl.getUniformLocation(shaderprogram, 'u_color');
        gl.uniform4fv(u_col, current_color);
        gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

        gl.uniform4fv(u_col, new Float32Array([0, 0, 0, 0.5]));
        let u_ps = gl.getUniformLocation(shaderprogram, 'u_pointsize');
        gl.uniform1f(u_ps, sc * 20.);
        gl.bindBuffer(gl.ARRAY_BUFFER, eye_vb);
        gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_pos);
        gl.drawArrays(gl.POINTS, 0, 1);
      }
    }
  </script>

  <body>
    <canvas id="c"></canvas>
  </body>
</html>


