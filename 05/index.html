<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Assignment 5 - Part 3</title>

    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000000;
      }
      canvas {
        display: block;
      }
    </style>

    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
      import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
      import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

      let scene, camera, renderer, effect, controls;
      let light, ambientLight;
      let loader;
      let stats;
      let pane;

      const qIdentity = new THREE.Quaternion(0, 0, 0, 1);
      const q180 = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 1, 0),
        Math.PI
      );

      window.SCENE = {
        anaglyph: false,
        ambColor: { r: 1, g: 1, b: 1 },
        polyRoot: null,
        rotate_poly: false,
        blenderRoot: null,
        rotate_blender: false,
        blender_helper: null,
        blenderMesh: null,
        blender_old_material: null,
        do_rotate_poly() {
          window.SCENE.rotate_poly = !window.SCENE.rotate_poly;
        },
        do_rotate_blender() {
          window.SCENE.rotate_blender = !window.SCENE.rotate_blender;
        },
        change_material() {
          if (!window.SCENE.blenderMesh) return;
          const mesh = window.SCENE.blenderMesh;
          if (!window.SCENE.blender_old_material) {
            window.SCENE.blender_old_material = mesh.material.clone();
            mesh.material = new THREE.MeshNormalMaterial();
          } else {
            mesh.material = window.SCENE.blender_old_material.clone();
            window.SCENE.blender_old_material = null;
          }
        }
      };

      window.onload = function () {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 25);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        effect = new AnaglyphEffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);

        light = new THREE.DirectionalLight(0xffffff, 2.0);
        light.position.set(20, 40, 20);
        scene.add(light);

        ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const axes = new THREE.AxesHelper(5);
        scene.add(axes);

        const debugGeo = new THREE.BoxGeometry(1, 1, 1);
        const debugMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const debugCube = new THREE.Mesh(debugGeo, debugMat);
        scene.add(debugCube);

        loader = new GLTFLoader();

        loadPolyMesh();
        loadBlenderMesh();

        controls = new OrbitControls(camera, renderer.domElement);

        stats = new Stats();
        document.body.appendChild(stats.dom);

        pane = new Pane();
        setupUI();

        window.addEventListener('resize', onWindowResize);

        animate();
      };

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        effect.setSize(window.innerWidth, window.innerHeight);
      }

      function normalizeAndCenter(root, targetSize = 10) {
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);

        console.log('Model size:', size);
        console.log('Model center before:', center);

        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const scale = targetSize / maxDim;
        root.scale.setScalar(scale);

        const box2 = new THREE.Box3().setFromObject(root);
        const center2 = new THREE.Vector3();
        box2.getCenter(center2);
        root.position.sub(center2);

        console.log('Model center after:', center2);
      }

      function findFirstMesh(root) {
        let found = null;
        root.traverse((obj) => {
          if (!found && obj.isMesh) found = obj;
        });
        return found;
      }

      function setupUI() {
        const sceneui = pane.addFolder({ title: 'Scene' });

        sceneui.addBinding(window.SCENE, 'anaglyph', { label: 'Anaglyph' });

        sceneui.addBinding(light.position, 'x', { min: -100, max: 100, label: 'Light X' });
        sceneui.addBinding(light.position, 'y', { min: -100, max: 100, label: 'Light Y' });
        sceneui.addBinding(light.position, 'z', { min: -100, max: 100, label: 'Light Z' });
        sceneui.addBinding(light, 'intensity', { min: 0, max: 10, label: 'Light Intensity' });

        sceneui.addBinding(window.SCENE.ambColor, 'r', { min: 0, max: 1, label: 'Ambient R' });
        sceneui.addBinding(window.SCENE.ambColor, 'g', { min: 0, max: 1, label: 'Ambient G' });
        sceneui.addBinding(window.SCENE.ambColor, 'b', { min: 0, max: 1, label: 'Ambient B' });
      }

      function loadPolyMesh() {
        console.log('Loading 12_1_2025.glb...');
        loader.load(
          '12_1_2025.glb',
          (gltf) => {
            console.log('12_1_2025.glb loaded');
            const root = gltf.scene || gltf.scenes?.[0];
            if (!root) {
              console.error('No scene in 12_1_2025.glb');
              return;
            }

            normalizeAndCenter(root, 10);
            root.position.x = 8;

            const mesh = findFirstMesh(root);
            window.SCENE.polyRoot = root;

            scene.add(root);

            const polyui = pane.addFolder({ title: 'PolyCam Mesh' });
            if (mesh && mesh.material) {
              polyui.addBinding(mesh.material, 'wireframe', { label: 'Wireframe' });
            }
            polyui.addButton({ title: 'Rotate 180°' }).on('click', () => {
              window.SCENE.do_rotate_poly();
            });
          },
          undefined,
          (err) => {
            console.error('Error loading 12_1_2025.glb:', err);
          }
        );
      }

      function loadBlenderMesh() {
        console.log('Loading cup.glb...');
        loader.load(
          'cup.glb',
          (gltf) => {
            console.log('cup.glb loaded');
            const root = gltf.scene || gltf.scenes?.[0];
            if (!root) {
              console.error('No scene in cup.glb');
              return;
            }

            normalizeAndCenter(root, 10);
            root.position.x = -8;

            const mesh = findFirstMesh(root);
            window.SCENE.blenderRoot = root;
            window.SCENE.blenderMesh = mesh;

            scene.add(root);

            if (mesh) {
              const helper = new VertexNormalsHelper(mesh, 0.5, 0x0000ff);
              helper.visible = false;
              scene.add(helper);
              window.SCENE.blender_helper = helper;

              const blenderui = pane.addFolder({ title: 'Blender Mesh' });
              blenderui.addBinding(helper, 'visible', { label: 'Show Normals' });
              blenderui.addButton({ title: 'Rotate 180°' }).on('click', () => {
                window.SCENE.do_rotate_blender();
              });
              blenderui.addButton({ title: 'Change Material' }).on('click', () => {
                window.SCENE.change_material();
              });
            }
          },
          undefined,
          (err) => {
            console.error('Error loading cup.glb:', err);
          }
        );
      }

      function animate() {
        requestAnimationFrame(animate);

        stats.begin();

        ambientLight.color.setRGB(
          window.SCENE.ambColor.r,
          window.SCENE.ambColor.g,
          window.SCENE.ambColor.b
        );

        if (window.SCENE.polyRoot) {
          const target = window.SCENE.rotate_poly ? q180 : qIdentity;
          window.SCENE.polyRoot.quaternion.slerp(target, 0.02);
        }

        if (window.SCENE.blenderRoot) {
          const target = window.SCENE.rotate_blender ? q180 : qIdentity;
          window.SCENE.blenderRoot.quaternion.slerp(target, 0.02);
          if (window.SCENE.blender_helper) {
            window.SCENE.blender_helper.update();
          }
        }

        controls.update();

        if (window.SCENE.anaglyph) {
          effect.render(scene, camera);
        } else {
          renderer.render(scene, camera);
        }

        stats.end();
      }
    </script>
  </head>
  <body></body>
</html>

