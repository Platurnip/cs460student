<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Assignment 5 - Part 3</title>

    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000000;
      }

      canvas {
        display: block;
      }
    </style>

    <!-- stats.js -->
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

    <!-- ES module shims + import map for three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
      import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
      import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

      let scene, camera, renderer, effect, controls;
      let light, ambientLight;
      let loader;
      let stats;
      let pane;

      // quaternions for 0째 and 180째 around Y
      const qIdentity = new THREE.Quaternion(0, 0, 0, 1);
      const q180 = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 1, 0),
        Math.PI
      );

      // global state
      window.SCENE = {
        anaglyph: false,
        ambColor: { r: 1, g: 1, b: 1 },

        polyRoot: null,
        polyMesh: null,
        rotate_poly: false,
        do_rotate_poly() {
          window.SCENE.rotate_poly = !window.SCENE.rotate_poly;
        },

        blenderRoot: null,
        blenderMesh: null,
        rotate_blender: false,
        do_rotate_blender() {
          window.SCENE.rotate_blender = !window.SCENE.rotate_blender;
        },

        blender_helper: null,
        blender_old_material: null,
        change_material() {
          if (!window.SCENE.blenderMesh) return;
          const mesh = window.SCENE.blenderMesh;

          if (!window.SCENE.blender_old_material) {
            window.SCENE.blender_old_material = mesh.material.clone();
            mesh.material = new THREE.MeshNormalMaterial();
          } else {
            mesh.material = window.SCENE.blender_old_material.clone();
            window.SCENE.blender_old_material = null;
          }
        }
      };

      window.onload = function () {
        // Scene + camera
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.position.set(0, 10, 40);

        // Renderer + anaglyph
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        effect = new AnaglyphEffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);

        // Lights
        light = new THREE.DirectionalLight(0xffffff, 2.0);
        light.position.set(20, 40, 20);
        scene.add(light);

        ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Loader
        loader = new GLTFLoader();

        // Load the two models
        loadPolyMesh();    // original PolyCam 12_1_2025.glb
        loadBlenderMesh(); // cleaned cup.glb

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);

        // Stats
        stats = new Stats();
        document.body.appendChild(stats.dom);

        // UI
        pane = new Pane();
        setupUI();

        window.addEventListener('resize', onWindowResize);

        animate();
      };

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        effect.setSize(window.innerWidth, window.innerHeight);
      }

      // Normalize a model: center it at origin and scale to a target size
      function normalizeAndCenter(root, targetSize = 10) {
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);

        // Avoid divide-by-zero
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const scale = targetSize / maxDim;

        root.scale.setScalar(scale);

        // After scaling, recenter again
        const box2 = new THREE.Box3().setFromObject(root);
        const center2 = new THREE.Vector3();
        box2.getCenter(center2);
        root.position.sub(center2); // moves model so its center is at (0,0,0)
      }

      function findFirstMesh(root) {
        let found = null;
        root.traverse((obj) => {
          if (!found && obj.isMesh) {
            found = obj;
          }
        });
        return found;
      }

      function setupUI() {
        const sceneui = pane.addFolder({ title: 'Scene' });

        sceneui.addBinding(window.SCENE, 'anaglyph', { label: 'Anaglyph' });

        sceneui.addBinding(light.position, 'x', {
          min: -100,
          max: 100,
          label: 'Light X'
        });
        sceneui.addBinding(light.position, 'y', {
          min: -100,
          max: 100,
          label: 'Light Y'
        });
        sceneui.addBinding(light.position, 'z', {
          min: -100,
          max: 100,
          label: 'Light Z'
        });
        sceneui.addBinding(light, 'intensity', {
          min: 0,
          max: 10,
          label: 'Light Intensity'
        });

        sceneui.addBinding(window.SCENE.ambColor, 'r', {
          min: 0,
          max: 1,
          label: 'Ambient R'
        });
        sceneui.addBinding(window.SCENE.ambColor, 'g', {
          min: 0,
          max: 1,
          label: 'Ambient G'
        });
        sceneui.addBinding(window.SCENE.ambColor, 'b', {
          min: 0,
          max: 1,
          label: 'Ambient B'
        });
      }

      function loadPolyMesh() {
        loader.load('12_1_2025.glb', (gltf) => {
          const root = gltf.scene;
          normalizeAndCenter(root, 10);

          // move to the RIGHT
          root.position.x = 8;

          const mesh = findFirstMesh(root);
          window.SCENE.polyRoot = root;
          window.SCENE.polyMesh = mesh;

          scene.add(root);

          const polyui = pane.addFolder({ title: 'PolyCam Mesh' });
          if (mesh && mesh.material) {
            polyui.addBinding(mesh.material, 'wireframe', { label: 'Wireframe' });
          }
          polyui.addButton({ title: 'Rotate 180째' }).on('click', () => {
            window.SCENE.do_rotate_poly();
          });
        });
      }

      function loadBlenderMesh() {
        loader.load('cup.glb', (gltf) => {
          const root = gltf.scene;
          normalizeAndCenter(root, 10);

          // move to the LEFT
          root.position.x = -8;

          const mesh = findFirstMesh(root);
          window.SCENE.blenderRoot = root;
          window.SCENE.blenderMesh = mesh;

          scene.add(root);

          // Vertex normals helper for the cleaned model
          if (mesh) {
            const helper = new VertexNormalsHelper(mesh, 0.5, 0x0000ff);
            helper.visible = false;
            scene.add(helper);
            window.SCENE.blender_helper = helper;

            const blenderui = pane.addFolder({ title: 'Blender Mesh' });
            blenderui.addBinding(helper, 'visible', { label: 'Show Normals' });
            blenderui.addButton({ title: 'Rotate 180째' }).on('click', () => {
              window.SCENE.do_rotate_blender();
            });
            blenderui.addButton({ title: 'Change Material' }).on('click', () => {
              window.SCENE.change_material();
            });
          }
        });
      }

      function animate() {
        requestAnimationFrame(animate);

        stats.begin();

        // Update ambient color from UI
        ambientLight.color.setRGB(
          window.SCENE.ambColor.r,
          window.SCENE.ambColor.g,
          window.SCENE.ambColor.b
        );

        // Smoothly rotate poly model
        if (window.SCENE.polyRoot) {
          const target = window.SCENE.rotate_poly ? q180 : qIdentity;
          window.SCENE.polyRoot.quaternion.slerp(target, 0.02);
        }

        // Smoothly rotate blender model
        if (window.SCENE.blenderRoot) {
          const target = window.SCENE.rotate_blender ? q180 : qIdentity;
          window.SCENE.blenderRoot.quaternion.slerp(target, 0.02);

          if (window.SCENE.blender_helper) {
            window.SCENE.blender_helper.update();
          }
        }

        controls.update();

        if (window.SCENE.anaglyph) {
          effect.render(scene, camera);
        } else {
          renderer.render(scene, camera);
        }

        stats.end();
      }
    </script>
  </head>
  <body></body>
</html>

